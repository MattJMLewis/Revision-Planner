//
//  AddViewModel.swift
//  Revision Planner
//
//  Created by Matthew Lewis on 18/02/2021.
//

import Foundation
import Combine
import EventKit

class AddSubjectViewModel: ObservableObject {
    
    @Published var name:String = ""
    
    @Published var startDate:Date = Date()
    @Published var endDate:Date = DateHelper.addToDate(date: Date(), month: 1)
    
    @Published var startTime:Date = DateHelper.setTimeOnDate(date: Date(), hour: 9)
    @Published var endTime:Date = DateHelper.setTimeOnDate(date: Date(), hour: 17)
    
    @Published var sessionLength:String = "30" {
        didSet {
            let filtered = sessionLength.filter { $0.isNumber }
            
            if sessionLength != filtered {
                sessionLength = filtered
            }
        }
    }
    
    @Published var dateRanges:[DateRange] = []
    
    @Published var formErrors:String = ""
    @Published var showAlert:Bool = false
    @Published var openAddTopicPage:Bool = false
   
    // Leave this empty for now, will fill later
    @Published var subject:Subject = Subject()
    
    func add()
    {
        if self.verifyData() {

            var excludedStartTimes: [Date] = []
            var excludedEndTimes: [Date] = []
            
            for dateRange in dateRanges
            {
                excludedStartTimes.append(dateRange.startDate)
                excludedEndTimes.append(dateRange.endDate)
            }
            
            self.subject = SubjectStorage.shared.add(name: name, progress: 0.0, startDate: startDate, endDate: endDate, startTime: startTime, endTime: endTime, sessionLength: Int(sessionLength)!, excludedStartTimes: excludedStartTimes, excludedEndTimes: excludedEndTimes)
            
            // We need to add the date ranges to a calendar
            let calendar = CalendarInterface.shared.createCalendar(title: (self.subject.calendarName()))
            
            for dateRange in dateRanges {

                let event = EKEvent(eventStore: CalendarInterface.shared.eventStore)
                event.title = "Excluded Time"
                event.startDate = DateHelper.copyTimeToOtherDate(timeDate: dateRange.startDate, targetDate: self.subject.startDate)
                event.endDate = DateHelper.copyTimeToOtherDate(timeDate: dateRange.endDate, targetDate: self.subject.startDate)
                event.notes = "This event was automatically generated by `Revision Planner`. Please do not delete it"
                event.calendar = calendar
                
                let recurrenceRule = EKRecurrenceRule(
                    recurrenceWith: .daily,
                    interval: 1,
                    end: EKRecurrenceEnd.init(end: subject.endDate)
                )
                
                event.recurrenceRules = [recurrenceRule]

                CalendarInterface.shared.createEvent(event: event)  // Error, do something

            }
            
            openAddTopicPage = true
                
        }
    }
    
    func deleteOldSubject()
    {
        if(name != "") {
            let subject = SubjectStorage.shared.fetchFirst()
            var calName = subject?.calendarName()
            
            CalendarInterface.shared.deleteCalendar(title: calName!)
            SubjectStorage.shared.deleteFirst()
            
            name = ""
        }
    }
    
    func addTimeRange()
    {
        
        dateRanges.append(DateRange(startDate: DateHelper.setTimeOnDate(date: Date(), hour: 12 + dateRanges.count), endDate: DateHelper.setTimeOnDate(date: Date(), hour: 13 + dateRanges.count)))
    }
    
    func deleteTimeRange(index: Int)
    {
        dateRanges.remove(at: index)
    }
    
    func verifyData() -> Bool
    {
        
        // Need to check excluded time doesn't overlap end of day
         
        var errors:[String]  = []
        // Make sure filled in
        if name.trimmingCharacters(in: .whitespaces) .isEmpty {
            errors.append("The name field cannot be empty")
        }
        
        if startDate > endDate
        {
            errors.append("The start date cannot be later than the end date")
        }
    
        if startTime > endTime
        {
            errors.append("The start time cannot be later than the end time")
        }
        
        if !dateRanges.isEmpty {
            let invalidRanges = dateRanges.filter({ $0.startDate > $0.endDate || $0.startDate == $0.endDate })
            
            if !invalidRanges.isEmpty
            {
                errors.append("The first time in a set of excluded times must be earlier than the second time")
            }
            
            var duplicateDates = false
            var datesOverlap = false
            
           
            for dateRange in dateRanges {
                let duplicates = dateRanges.filter({$0.startDate == dateRange.startDate && $0.endDate == dateRange.endDate})
                let overlaps = dateRanges.filter({($0.startDate...$0.endDate).overlaps(dateRange.startDate ... dateRange.endDate) == true })

                
                if(overlaps.count > 1) {
                    datesOverlap = true
                }
                
                if(duplicates.count > 1) {
                    duplicateDates = true
                }
            }
            
            
            if(duplicateDates) {
                errors.append("You cannot have duplicate excluded times")
            }
            
            if(datesOverlap) {
                errors.append("You cannot have overlapping excluded times")
            }
            
        }
        
        // Cannot have invalid data to do this step
        if errors.isEmpty {
            if sessionLength.isEmpty {
                errors.append("The session length field cannot be empty")
            }
            else {
                // Time avaiable in day to revise
                var delta = endTime - startTime
                
                for timeRange in dateRanges {
                    delta = delta - (timeRange.endDate - timeRange.startDate)
                }
            
                delta = delta - Double(sessionLength)! * 60
                
                if(delta <= 0)
                {
                    errors.append("The start time, end time, excluded times and session length do not provide enough time for a single session to occur in a day.")
                }
            }
        }
        
        if errors.isEmpty {
            return true
        }
        else
        {
            formErrors = errors.joined(separator: "\n")
            showAlert = true
            return false
        }
    }
}
